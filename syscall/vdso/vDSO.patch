diff --git a/linux-5.15.178/arch/x86/entry/vdso/Makefile b/linux-5.15.178/arch/x86/entry/vdso/Makefile
index c277c63..03225cc 100644
--- a/linux-5.15.178/arch/x86/entry/vdso/Makefile
+++ b/linux-5.15.178/arch/x86/entry/vdso/Makefile
@@ -24,7 +24,7 @@ VDSO32-$(CONFIG_X86_32)		:= y
 VDSO32-$(CONFIG_IA32_EMULATION)	:= y
 
 # files to link into the vdso
-vobjs-y := vdso-note.o vclock_gettime.o vgetcpu.o
+vobjs-y := vdso-note.o vclock_gettime.o vgetcpu.o vgetinfo.o
 vobjs32-y := vdso32/note.o vdso32/system_call.o vdso32/sigreturn.o
 vobjs32-y += vdso32/vclock_gettime.o
 vobjs-$(CONFIG_X86_SGX)	+= vsgx.o
diff --git a/linux-5.15.178/arch/x86/entry/vdso/vgetinfo.c b/linux-5.15.178/arch/x86/entry/vdso/vgetinfo.c
new file mode 100644
index 0000000..ba31b53
--- /dev/null
+++ b/linux-5.15.178/arch/x86/entry/vdso/vgetinfo.c
@@ -0,0 +1,45 @@
+#include <linux/kernel.h>
+#include <linux/user_taskinfo.h>
+// #include <asm/processor.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+// #define CS_BASES 2
+#include <vdso/datapage.h>
+#include <asm/vvar.h>
+
+
+// vvar 区域大小，通常为 4 * PAGE_SIZE
+#define VVAR_SIZE   (4 * PAGE_SIZE)
+#define VTASK_SIZE  (ALIGN(sizeof(struct task_struct), PAGE_SIZE) + PAGE_SIZE)
+
+extern char vvar_page;
+
+static inline void *get_task_addr(void)
+{
+    // vtask 区域在 vvar 区域上方
+    struct my_task_struct_view *view;
+    view = (struct my_task_struct_view *)(&vvar_page - VVAR_SIZE);
+    
+    return (void *)((char *)view + view->page_offset + PAGE_SIZE); // 计算 task_struct 的内核虚拟地址
+}
+
+int __vdso_get_task_struct_info(struct task_info *info)
+{
+    struct task_struct *task;
+    if (!info)
+        return -1;
+    
+    // 直接从映射的内存中读取task_struct
+    task = (struct task_struct *)get_task_addr();
+        
+    info->kaddr = task;
+    info->pid = task->pid;
+    
+    return 0;
+}
+
+// 这是用户空间调用的包装函数
+int get_task_struct_info(struct task_info *info)
+{
+    return __vdso_get_task_struct_info(info);
+}
diff --git a/linux-5.15.178/arch/x86/entry/vdso/vma.c b/linux-5.15.178/arch/x86/entry/vdso/vma.c
index a380f7e..99f562c 100644
--- a/linux-5.15.178/arch/x86/entry/vdso/vma.c
+++ b/linux-5.15.178/arch/x86/entry/vdso/vma.c
@@ -27,6 +27,8 @@
 #include <asm/cpufeature.h>
 #include <clocksource/hyperv_timer.h>
 
+#include <linux/user_taskinfo.h>
+
 #undef _ASM_X86_VVAR_H
 #define EMIT_VVAR(name, offset)	\
 	const size_t name ## _offset = offset;
@@ -54,6 +56,7 @@ void __init init_vdso_image(const struct vdso_image *image)
 }
 
 static const struct vm_special_mapping vvar_mapping;
+static const struct vm_special_mapping vtask_mapping;
 struct linux_binprm;
 
 static vm_fault_t vdso_fault(const struct vm_special_mapping *sm,
@@ -150,6 +153,8 @@ static inline struct page *find_timens_vvar_page(struct vm_area_struct *vma)
 static vm_fault_t vvar_fault(const struct vm_special_mapping *sm,
 		      struct vm_area_struct *vma, struct vm_fault *vmf)
 {
+	pr_info("vvar_fault: vma->vm_start = %lx, vma->vm_end = %lx, vmf->pgoff = %lx\n",
+		vma->vm_start, vma->vm_end, vmf->pgoff);
 	const struct vdso_image *image = vma->vm_mm->context.vdso_image;
 	unsigned long pfn;
 	long sym_offset;
@@ -228,6 +233,52 @@ static vm_fault_t vvar_fault(const struct vm_special_mapping *sm,
 	return VM_FAULT_SIGBUS;
 }
 
+#define VTASK_SIZE  (ALIGN(sizeof(struct task_struct), PAGE_SIZE) + PAGE_SIZE)
+
+static vm_fault_t vtask_fault(const struct vm_special_mapping *sm,
+                      struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	pr_info("vtask_fault: vma->vm_start = %lx, vma->vm_end = %lx, vmf->pgoff = %lx\n",
+        vma->vm_start, vma->vm_end, vmf->pgoff);
+	
+	unsigned long offset = vmf->pgoff << PAGE_SHIFT;
+
+	if (offset >= VTASK_SIZE)
+		return VM_FAULT_SIGBUS;
+
+	unsigned long task_struct_offset = __pa((char *)current) & (~PAGE_MASK);
+	pr_info("_pa(current) = %lx, offset = %ld\n", __pa(current), task_struct_offset);
+	// 第一个页面用于映射 task_struct_view
+	if (vmf->pgoff == 0) {
+		pr_info("create a page for task_struct_view \npage_offset=%lx pid=%d\n", task_struct_offset, current->pid);
+		// 创建一个页面
+		struct page *page;
+        struct my_task_struct_view *view;
+        
+        // 分配一个页面用于存放结构体视图
+        page = alloc_page(GFP_KERNEL);
+        if (!page)
+            return VM_FAULT_OOM;
+            
+        // 获取页面地址并填充结构体
+        view = page_address(page);
+        memset(view, 0, PAGE_SIZE);  // 清空页面
+        
+        // 填充结构体信息
+        view->page_offset = task_struct_offset;
+        view->pid = current->pid;
+        
+        // 将该页映射到用户空间
+        get_page(page);
+        vmf->page = page;
+        return 0;
+	} else {
+		return vmf_insert_pfn(vma, vmf->address,
+			(__pa((char *)current + offset - PAGE_SIZE)) >> PAGE_SHIFT);
+		
+	}		
+}
+
 static const struct vm_special_mapping vdso_mapping = {
 	.name = "[vdso]",
 	.fault = vdso_fault,
@@ -237,6 +288,10 @@ static const struct vm_special_mapping vvar_mapping = {
 	.name = "[vvar]",
 	.fault = vvar_fault,
 };
+static const struct vm_special_mapping vtask_mapping = {
+    .name = "[vtask]",
+    .fault = vtask_fault,
+};
 
 /*
  * Add vdso and vvar mappings to current process.
@@ -245,23 +300,34 @@ static const struct vm_special_mapping vvar_mapping = {
  */
 static int map_vdso(const struct vdso_image *image, unsigned long addr)
 {
+	pr_info("map_vdso: mapping vdso image at addr 0x%lx (image size: 0x%lx, vvar offset: 0x%lx)\n",
+		addr, image->size, image->sym_vvar_start);
+	pr_info("current pid: %d command: %s kaddr: %p\n", current->pid, current->comm, current);
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
 	unsigned long text_start;
+	unsigned long vtask_start;
+	unsigned long vvar_start;
+	unsigned long vvar_size = -image->sym_vvar_start;
 	int ret = 0;
 
 	if (mmap_write_lock_killable(mm))
 		return -EINTR;
 
+
+	pr_info("fucksize = %lx\n", image->size - image->sym_vvar_start + VTASK_SIZE);
 	addr = get_unmapped_area(NULL, addr,
-				 image->size - image->sym_vvar_start, 0, 0);
+				 image->size - image->sym_vvar_start + VTASK_SIZE, 0, 0);
 	if (IS_ERR_VALUE(addr)) {
 		ret = addr;
 		goto up_fail;
 	}
 
-	text_start = addr - image->sym_vvar_start;
+	vtask_start = addr;
+	vvar_start = addr + VTASK_SIZE;
+	text_start = addr + VTASK_SIZE + vvar_size;
 
+	pr_info("map_vdso: trying to map vdso area addr=%lx size=%lx\n", text_start, image->size);
 	/*
 	 * MAYWRITE to allow gdb to COW and set breakpoints
 	 */
@@ -277,20 +343,52 @@ static int map_vdso(const struct vdso_image *image, unsigned long addr)
 		goto up_fail;
 	}
 
-	vma = _install_special_mapping(mm,
-				       addr,
-				       -image->sym_vvar_start,
-				       VM_READ|VM_MAYREAD|VM_IO|VM_DONTDUMP|
-				       VM_PFNMAP,
-				       &vvar_mapping);
+	pr_info("map_vdso: trying to map vvar area addr=%lx size=%lx\n", vvar_start, vvar_size);
+	// 映射vvar区域
+    vma = _install_special_mapping(mm,
+					   vvar_start,
+                       vvar_size,
+                       VM_READ|VM_MAYREAD|VM_IO|VM_DONTDUMP|
+                       VM_PFNMAP,
+                       &vvar_mapping);
+
+    if (IS_ERR(vma)) {
+        ret = PTR_ERR(vma);
+        do_munmap(mm, text_start, image->size, NULL);
+        goto up_fail;
+    }
+	
+
+	pr_info("map_vdso: trying to map vtask area addr=%lx size=%lx\n", vtask_start, VTASK_SIZE);
+
+    // 映射task_struct到vvar紧邻的区域
+    vma = _install_special_mapping(mm,
+					  vtask_start, 
+                      VTASK_SIZE,
+                      VM_READ|VM_MAYREAD|VM_DONTDUMP|VM_IO|VM_PFNMAP|VM_WIPEONFORK,
+                      &vtask_mapping);
+     
+    if (IS_ERR(vma)) {
+		// debug
+		pr_info("map_vdso: ERROR: Failed to install vtask mapping\n");
+		struct vm_area_struct *tmp;
+		pr_info("map_vdso: Dumping all VMAs for current process (pid=%d):\n", current->pid);
+		for (tmp = mm->mmap; tmp; tmp = tmp->vm_next) {
+			pr_info("  VMA: start=0x%lx end=0x%lx flags=0x%lx name=%s\n",
+					tmp->vm_start, tmp->vm_end, tmp->vm_flags,
+					tmp->vm_file ? (tmp->vm_file->f_path.dentry->d_name.name) :
+					(tmp->vm_ops && tmp->vm_ops->name ? tmp->vm_ops->name : ""));
+		}
 
-	if (IS_ERR(vma)) {
-		ret = PTR_ERR(vma);
-		do_munmap(mm, text_start, image->size, NULL);
-	} else {
-		current->mm->context.vdso = (void __user *)text_start;
-		current->mm->context.vdso_image = image;
-	}
+        ret = PTR_ERR(vma);
+		pr_info("ret = %d\n", ret);
+        do_munmap(mm, text_start, image->size, NULL);
+		do_munmap(mm, vvar_start, vvar_size, NULL);
+        goto up_fail;
+    }
+
+	current->mm->context.vdso = (void __user *)text_start;
+	current->mm->context.vdso_image = image;
 
 up_fail:
 	mmap_write_unlock(mm);
diff --git a/linux-5.15.178/include/linux/user_taskinfo.h b/linux-5.15.178/include/linux/user_taskinfo.h
new file mode 100644
index 0000000..235e0ee
--- /dev/null
+++ b/linux-5.15.178/include/linux/user_taskinfo.h
@@ -0,0 +1,11 @@
+
+struct my_task_struct_view {
+    int page_offset; // 任务结构体在页内的偏移
+    pid_t pid; // 进程ID
+};
+
+struct task_info {
+    struct task_struct *kaddr; // 任务结构体指针(内核虚地址)
+    pid_t pid;
+};
+
diff --git a/syscall/vdso/test_vdso.c b/syscall/vdso/test_vdso.c
new file mode 100644
index 0000000..a9f6061
--- /dev/null
+++ b/syscall/vdso/test_vdso.c
@@ -0,0 +1,99 @@
+#include <cstddef>
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <unistd.h>
+#include <cstdlib>
+#include <dlfcn.h>
+#include <sys/wait.h>
+
+extern "C" {
+
+struct task_info {
+    void *task_struct_ptr;
+    pid_t pid;
+    // other key fields...
+};
+
+int get_task_struct_info(struct task_info *info);
+
+
+static void *func_sym = NULL;
+
+int get_task_struct_info(struct task_info *info) {
+    if (func_sym == NULL) {
+        void *handle = dlopen("linux-vdso.so.1", RTLD_LAZY);
+        if (!handle) {
+            std::cerr << "vdso not found" << std::endl;
+            return -1;
+        }
+        func_sym = dlsym(handle, "__vdso_get_task_struct_info");
+        if (!func_sym) {
+            std::cerr << "symbol not found" << std::endl;
+            dlclose(handle);
+            return -1;
+        }
+    }
+    int (*get_task_struct_info_func)(struct task_info *out) = (int (*)(struct task_info *))func_sym;
+    int ret = get_task_struct_info_func(info);
+    return ret;
+}
+
+}
+
+int main() {
+    task_info info;
+    if (get_task_struct_info(&info) != 0) {
+        std::cerr << "Failed to get task struct info" << std::endl;
+        return 1;
+    }
+    pid_t pid_vdso = info.pid;
+    std::ifstream stat_file("/proc/self/stat");
+    if (!stat_file.is_open()) {
+        std::cerr << "Failed to open /proc/self/stat" << std::endl;
+        return 1;
+    }
+    pid_t pid_proc;
+    stat_file >> pid_proc;
+    stat_file.close();
+    if (pid_proc != pid_vdso) {
+        std::cerr << "PID mismatch: pid from /proc/self/stat is " << pid_proc
+                  << ", pid from vDSO is " << pid_vdso << std::endl;
+    } else {
+        std::cout << "PID matches: " << pid_proc << std::endl;
+    }
+    const int num_forks = 5;
+    for (int i = 0; i < num_forks; ++i) {
+        pid_t pid = fork();
+        if (pid < 0) {
+            std::cerr << "Failed to fork" << std::endl;
+            return 1;
+        } else if (pid == 0) {
+            task_info child_info;
+            if (get_task_struct_info(&child_info) != 0) {
+                std::cerr << "Child failed to get task struct info" << std::endl;
+                exit(1);
+            }
+            pid_t child_pid_vdso = child_info.pid;
+            std::ifstream child_stat_file("/proc/self/stat");
+            if (!child_stat_file.is_open()) {
+                std::cerr << "Child failed to open /proc/self/stat" << std::endl;
+                exit(1);
+            }
+            pid_t child_pid_proc;
+            child_stat_file >> child_pid_proc;
+            child_stat_file.close();
+            if (child_pid_proc != child_pid_vdso) {
+                std::cerr << "Child PID mismatch: pid from /proc/self/stat is " << child_pid_proc
+                          << ", pid from vDSO is " << child_pid_vdso << std::endl;
+            } else {
+                std::cout << "Child PID matches: " << child_pid_proc << std::endl;
+            }
+            exit(0);
+        } else {
+            int status;
+            waitpid(pid, &status, 0);
+        }
+    }
+    return 0;
+}
